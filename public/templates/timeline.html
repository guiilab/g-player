<!--
timeline.html
G-Player Data Visualization

- A template file for the right legend menu

Created: Feb 28, 2015
Authors:
Tariq Anwar
-->



  <div class="navbar navbar-default navbar-fixed-bottom">
  <div class = "container"> 
  <select id="playback-players-list" >
		<option value="">Select Player</option>
  </select>
  </div>
  </div>  
  
  <script>
   var control;
   var playback;
   var myLayer;
   var featuregroup;

  $("#playback-players-list").change(function() {
      var index = $("select[id='playback-players-list'] option:selected").index();  //get index of selected player
      $(".lp").remove();
	    var vis = Visualizer.getTimelineData();  //getting players data 
      var playbackOptions = {};
    
      var c = parseInt(index);   

       playback = new L.Playback(map, vis[c],null, playbackOptions); //playback of selected player
       control = new L.Playback.Control(playback);
       control.addTo(map);

	////////////////////////             BRUSH                /////////////////////////

       if(myLayer != undefined){    //remove previous data and layers if present
            myLayer.clearLayers();
            map.removeLayer(myLayer);
            $("#lay").remove();
            $("#brush").empty();
       }
       
	     myLayer = L.geoJson().addTo(map);
		   myLayer.addData(settings.brushLayer[c]);
		   setBrush(settings.brushLayer[c]);
		
		function pointColor(feature) {
			return feature.properties.start> 5 ? '#f55' : '#a00';
		}

		function pointRadius(feature) {
			return 6;
		}
	
/*
author: Tariq Anwar
created: Feb 22, 2016
purpose: Adding D3 brush component.
argument: the formatted data 
*/		
	function setBrush(data) {
   // console.log(data.features.properties.start[1]);
    var t=[];
    var container = d3.select('#brush'),
       width =750,    
       height = 100;
       margin = {top: 50, right: 50, bottom:300, left: 640};
     
    var timeExtent = d3.extent(data.features, function(d) {
        t.push(new Date(d.properties.start));  //just top two entries are required , could be removed;
        return new Date(d.properties.start);
    });

    var svg = container.append('svg')
        .attr("class", "grid-background")
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

    var context = svg.append('g')
        .attr('class', 'context')
        .attr('transform', 'translate(' +
            margin.left + ',' +
            margin.top + ')');
       
 
    var x = d3.time.scale()
        .range([0, width])
        .domain(timeExtent); 

    var xAxis = d3.svg.axis()  // X axis 
        .scale(x);
          

    var brush = d3.svg.brush()
        .x(x)
        .extent([t[0],t[5]])  // setting the initial window size
        .on('brush', brushend);  


    // this draws red circle over time where data is found 
	context.selectAll('circle.quake')
		   .data(data.features)
		   .enter()
		   .append('circle')
       .attr('id','circle')
		   .attr('transform', function(d) {
         // red circles for the data points
				return 'translate(' + [x(new Date(d.properties.start)), height/2] + ')';
			    })
		   .attr('r', pointRadius)
		   .attr('opacity', 0.5)
		   .attr('stroke', '#fff')
		   .attr('stroke-width',0.5)
		   .attr('fill', pointColor);

	context.append('g')
			.attr('class', 'x brush')
      .attr('id','lay')
			.call(brush)
      .call(brush.event)
			.selectAll('rect')
			.attr('y', -6)
			.attr('height', height);  

     
  context.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);   

        function brushend() {
        var filter;
        if (brush.empty()) {
            filter = function() { return true; 
             }
        } else {
            // Otherwise, restrict features to only things in the brush extent.
            filter = function(feature) {
              //console.log("strart"+feature.properties.start);
              //console.log("zero"+brush.extent()[0] +"one"+brush.extent()[1]);
                return feature.properties.start > +brush.extent()[0] &&
                    feature.properties.start < (+brush.extent()[1]);
            };
        }
        var filtered = data.features.filter(filter);
             myLayer.clearLayers()
            .addData(filtered);
        }


// WIP : currently does not perform any task, was trying to move window slider automatically 
    function drawBrush() {
    // define our brush extent to be begin and end of the year
        brush.extent(timeExtent)

    // now draw the brush to match our extent
    // use transition to slow it down so we can see what is happening
    // remove transition so just d3.select(".brush") to just draw
        brush(d3.select("#brush").transition());

    // now fire the brushstart, brushmove, and brushend events
    // remove transition so just d3.select(".brush") to just draw
        brush.event(d3.select("#brush").transition().delay(10))
  }

}



///////////////////////////////////////////////////////	
			 
			 
   //     } 
  });
  
  
  </script>
