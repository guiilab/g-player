<!--
timeline.html
G-Player Data Visualization

- A template file for the right legend menu

Created: Feb 28, 2015
Authors:
Tariq Anwar
-->



  <div class="navbar navbar-default navbar-fixed-bottom">
  <div class = "container"> 
  <select id="playback-players-list" >
    <option value="">Select Player</option>
  </select>
  </div>
  </div>  
  
  <script>
   var control;
   var playback;
   var myLayer;
   var featuregroup;

    // Colors for AwesomeMarkers
    var _colorIdx = 0,
        _colors = [
          'orange',
          'green',
          'blue',
          'purple',
          'darkred',
          'cadetblue',
          'red',
          'darkgreen',
          'darkblue',
          'darkpurple'
        ];
        
    function _assignColor() {
        return _colors[_colorIdx++%10];
    }

  $("#playback-players-list").change(function() {
     var player_id =  $("select[id='playback-players-list']").val();
     var  col_index = _.findWhere(settings.players, { 'playerID' : parseInt(player_id) });
     //console.log("Index"+col_index +"CCC"+col_index.color);

      var index = $("select[id='playback-players-list'] option:selected").index();  //get index of selected player
      $(".lp").remove();
      //var vis = Visualizer.getTimelineData();  //getting players data 
      var playbackOptions = {
          marker: function(){
            return {
                icon: L.AwesomeMarkers.icon({
                    prefix: 'fa',
                    icon: 'bullseye', 
                    markerColor: _assignColor()
                    //markerColor: col_index.color
                }) 
            };
        } 
      };
    
         var c = parseInt(index);   
        //settings.tracks.splice(0,1);
        console.log(settings.tracks.length);
       playback = new L.Playback(map,settings.tracks,null, playbackOptions); //playback of selected player
       control = new L.Playback.Control(playback);
       control.addTo(map);

  ////////////////////////             BRUSH                /////////////////////////

       if(myLayer != undefined){    //remove previous data and layers if present
            myLayer.clearLayers();
            map.removeLayer(myLayer);
            $("#lay").remove();
            $("#brush").empty();
       }
       
       myLayer = L.geoJson().addTo(map);
       myLayer.addData(settings.brushLayer[c]);
       setBrush(settings.brushLayer[c]);
    
    function pointColor(feature) {
      return feature.properties.start> 5 ? '#f55' : '#a00';
    }

    function pointRadius(feature) {
      return 6;
    }
  
/*
author: Tariq Anwar
created: Feb 22, 2016
purpose: Adding D3 brush component.
argument: the formatted data 
*/    
  function setBrush(data) {
   // console.log(data.features.properties.start[1]);
    var t=[];
    var container = d3.select('#brush'),
       width =750,    
       height = 100;
       margin = {top: 50, right: 50, bottom:100, left: 640};
     
    var timeExtent = d3.extent(data.features, function(d) {
        t.push(new Date(d.properties.start));  //just top two entries are required , could be removed;
        return new Date(d.properties.start);
    });

    var svg = container.append('svg')
        .attr("class", "grid-background")
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

    var context = svg.append('g')
        .attr('class', 'context')
        .attr('transform', 'translate(' +
            margin.left + ',' +
            margin.top + ')');
       
 
    var x = d3.time.scale()
        .range([0, width])
        .domain(timeExtent); 

    var xAxis = d3.svg.axis()  // X axis 
        .scale(x);
          

    var brush = d3.svg.brush()
        .x(x)
        .extent([t[0],t[5]])  // setting the initial window size
        .on('brush', brushend);  


    // this draws red circle over time where data is found 
  context.selectAll('circle.quake')
       .data(data.features)
       .enter()
       .append('circle')
       .attr('id','circle')
       .attr('transform', function(d) {
         // red circles for the data points
        return 'translate(' + [x(new Date(d.properties.start)), height/2] + ')';
          })
       .attr('r', pointRadius)
       .attr('opacity', 0.5)
       .attr('stroke', '#fff')
       .attr('stroke-width',0.5)
       .attr('fill', pointColor);

  context.append('g')
      .attr('class', 'x brush')
      .attr('id','lay')
      .call(brush)
      .call(brush.event)
      .selectAll('rect')
      .attr('y', -6)
      .attr('height', height);  

     
  context.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);   

        function brushend() {
        var filter;
        if (brush.empty()) {
            filter = function() { return true; 
             }
        } else {
            // Otherwise, restrict features to only things in the brush extent.
            filter = function(feature) {
               console.log("strart"+feature.properties.start);
              console.log(+brush.extent()[0].getMilliseconds());

                return feature.properties.start > +brush.extent()[0] &&
                    feature.properties.start < (+brush.extent()[1]);
            };
        }
        var filtered = data.features.filter(filter);
             myLayer.clearLayers()
            .addData(filtered);

            //  settings.window.start = feature.properties.start.getMilliseconds();
            //  settings.window.end =  (feature.properties.start + 200).getMilliseconds();
            //  Visualizer.refresh();     
        }

// WIP : currently does not perform any task, was trying to move window slider automatically 
    function drawBrush() {
    // define our brush extent to be begin and end of the year
        brush.extent(timeExtent)

    // now draw the brush to match our extent
    // use transition to slow it down so we can see what is happening
    // remove transition so just d3.select(".brush") to just draw
        brush(d3.select("#brush").transition());

    // now fire the brushstart, brushmove, and brushend events
    // remove transition so just d3.select(".brush") to just draw
        brush.event(d3.select("#brush").transition().delay(10))
  }

}



/////////////////////////////////////////////////////// 
       
       
   //     } 
  });
  
  
  </script>
